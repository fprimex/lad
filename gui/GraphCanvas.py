#-*- coding: UTF-8 -*-
#
# generated by wxGlade 1.1.0pre on Fri Oct  7 12:21:21 2022
#

import wx
# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade

import math
import numpy as np
import networkx as nx
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.backend_bases import MouseButton
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wxagg import NavigationToolbar2WxAgg

matplotlib.use('WXAgg')

class GraphCanvas(wx.Panel):
  def __init__(self, *args, **kwds):
    kwds["style"] = kwds.get("style", 0)
    wx.Panel.__init__(self, *args, **kwds)
    self.Layout()
    # end wxGlade

    self.selected_nodes = []
    self.selected_edges = []
    self.selection_rect = None

    self.client_size = wx.Size(0, 0)
    self.node_radius = 0.049
    self.node_search_dist = 0.02
    self.edge_search_dist = 0.02

    self.xmin = self.ymin = -1.0
    self.xmax = self.ymax = 1.0
    self.xscale = self.yscale = 1.0

    self.graph_colors = []
    self.graph_colors.append(wx.RED)
    self.graph_colors.append(wx.BLACK)
    self.graph_colors.append(wx.BLUE)
    self.graph_colors.append(wx.GREEN)
    self.graph_colors.append(wx.CYAN)
    self.graph_colors.append(wx.LIGHT_GREY)

    self.MOUSE_MODE_VERTEX = 0
    self.MOUSE_MODE_SELECTION = 1
    self.MOUSE_MODE_LOCK = 2
    self.mouse_mode = self.MOUSE_MODE_VERTEX

    self.__DRAG_NONE = 0
    self.__DRAG_START = 1
    self.__DRAG_DRAGGING = 2
    self.__drag_start_pos = np.array([0.0, 0.0])
    self.__drag_node = None
    self.__drag_compensation = np.array([0,0, 0.0])
    self.__drag_mode = self.__DRAG_NONE
    self.__drag_vector = np.array([0.0, 0.0])

    self.on_node_create_funcs = []
    self.on_edge_create_funcs = []
    self.on_node_delete_funcs = []
    self.on_edge_delete_funcs = []
    self.on_node_select_funcs = []
    self.on_edge_select_funcs = []
    self.on_drag_end_funcs = []

    #self.G = nx.Graph()
    self.G = nx.DiGraph()
    self.vlabel = {}
    self.vpos = {}
    self.vweight = {}
    self.vcolor = {}
    self.var_exps = {u"order": u"G.order()", u"size": u"G.size()"}
    self.vars = {u"order": 0, u"size": 0}

    self.figure = plt.figure()
    plt.gca().set_xlim(xmin=self.xmin, xmax=self.xmax)
    plt.gca().set_ylim(ymin=self.ymin, ymax=self.ymax)
    self.canvas = FigureCanvas(self, -1, self.figure)
    #plt.box(False)
    self.toolbar = NavigationToolbar2WxAgg(self.canvas)
    self.toolbar.Realize()

    # The possible matplotlib FigureCanvasBase events
    # https://matplotlib.org/stable/api/backend_bases_api.html
    # events = ['resize_event', 'draw_event', 'key_press_event',
    # 'key_release_event', 'button_press_event', 'button_release_event',
    # 'scroll_event', 'motion_notify_event', 'pick_event',
    # 'figure_enter_event', 'figure_leave_event', 'axes_enter_event',
    # 'axes_leave_event', 'close_event']

    self.canvas.mpl_connect('button_press_event',   self.MPLButton)
    self.canvas.mpl_connect('button_release_event', self.MPLButton)
    self.canvas.mpl_connect('motion_notify_event',  self.MPLButton)

    self.canvas.mpl_connect('key_press_event',      self.MPLKeyPress)

    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)
    sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)
    self.SetSizer(sizer)
    self.Fit()

    nx.draw_networkx(self.G, pos=self.vpos)
    plt.tight_layout(pad=-1)

  # Event signatures
  # Event(name, canvas, guiEvent=None)
  #
  # CloseEvent(name, canvas, guiEvent=None)
  # DrawEvent(name, canvas, renderer)
  # KeyEvent(name, canvas, key, x=0, y=0, guiEvent=None) + LocationEvent
  # LocationEvent(name, canvas, x, y, guiEvent=None)
  # MouseEvent(name, canvas, x, y, button=None, key=None, step=0,
  #            dblclick=False, guiEvent=None) + LocationEvent
  # PickEvent(name, canvas, mouseevent, artist, guiEvent=None, **kwargs)
  # ResizeEvent(name, canvas)

  def MPLButton(self, event):
    mouse_pos = np.array((event.xdata, event.ydata))

    if event.guiEvent.LeftDown():
      # clicked on a vertex?
      u = self.SearchNodes(mouse_pos)
      if u != None:
        if not event.guiEvent.CmdDown():
          self.DeselectAll()
        if u not in self.selected_nodes:
          self.SelectVertex(u)
        self.__drag_mode = self.__DRAG_START
        self.__drag_start_pos = mouse_pos
        self.__drag_node = u
        self.__drag_compensation = self.vpos[self.__drag_node] - self.__drag_start_pos
      else:
        # clicked on an edge?
        e = self.SearchEdges(mouse_pos)
        if e != None:
          if not event.guiEvent.CmdDown():
            self.DeselectAll()
          if e not in self.selected_edges:
            self.SelectEdge(e)
          self.__drag_mode = self.__DRAG_START
          self.__drag_start_pos = mouse_pos
          self.__drag_node = e[0]
          self.__drag_compensation = self.vpos[self.__drag_node] - mouse_pos
          self.__execute_callback(self.on_edge_select_funcs)
      if u == None and e == None:
        # didn't click on either
        if self.mouse_mode == self.MOUSE_MODE_VERTEX: # creation mode
          # naming based on order
          #num = self.G.order() + 1
          #label = "v%i" % num

          # Fill-in-the-gaps naming scheme
          v = 0
          label = "v0"

          while v in self.G.nodes() or label in self.vlabel.values():
            v += 1
            label = "v%i" % v

          self.vpos[v] = mouse_pos
          self.vlabel[v] = label
          self.vweight[v] = 1.0
          self.vcolor[v] = 1
          self.G.add_node(v)
          self.__execute_callback(self.on_node_create_funcs)

          if not event.guiEvent.CmdDown():
            self.DeselectAll()
          self.SelectVertex(v)
        
          self.__drag_mode = self.__DRAG_START
          self.__drag_start_pos = mouse_pos
          self.__drag_node = v
          self.__drag_compensation = np.array([0.0, 0.0])
        elif self.mouse_mode == self.MOUSE_MODE_SELECTION or self.mouse_mode == self.MOUSE_MODE_LOCK:
          self.DeselectAll()
          self.__drag_mode = self.__DRAG_START
          self.__drag_start_pos = mouse_pos
      
      #self.figure.clear()

    elif event.guiEvent.LeftUp(): # && self.__drag_mode != self.__DRAG_NONE)
      self.__drag_mode = self.__DRAG_NONE
      self.__drag_node = None
      self.__execute_callback(self.on_drag_end_funcs)
      self.selection_rect = None
    elif event.guiEvent.Dragging() and self.__drag_mode != self.__DRAG_NONE:
      if self.__drag_mode == self.__DRAG_START:
        tolerance = 0.005
        dx = math.fabs(mouse_pos[0] - self.__drag_start_pos[0])
        dy = math.fabs(mouse_pos[1] - self.__drag_start_pos[1])
        if dx <= tolerance and dy <= tolerance:
          return
        self.__drag_mode = self.__DRAG_DRAGGING
      elif self.__drag_mode == self.__DRAG_DRAGGING:
        if self.__drag_node != None and self.mouse_mode != self.MOUSE_MODE_LOCK:
          self.__drag_vector = mouse_pos - self.vpos[self.__drag_node] + self.__drag_compensation

          # init the corners of the bounding box
          self.box_x1 = self.vpos[self.__drag_node][0]
          self.box_x2 = self.vpos[self.__drag_node][0]
          self.box_y1 = self.vpos[self.__drag_node][1]
          self.box_y2 = self.vpos[self.__drag_node][1]

          nodes_to_move = set([])
          for e in self.selected_edges:
            nodes_to_move.add(e[0])
            self.__bound_box(self.vpos[e[0]])
            nodes_to_move.add(e[1])
            self.__bound_box(self.vpos[e[1]])
          for v in self.selected_nodes:
            if v not in nodes_to_move:
              nodes_to_move.add(v)
              self.__bound_box(self.vpos[v])

          # adjust the drag vector to account for canvas edge collisions
          # by dragging the corners of the bounding box first
          self.__drag(np.array([self.box_x1, self.box_y1]))
          self.__drag(np.array([self.box_x1, self.box_y2]))
          self.__drag(np.array([self.box_x2, self.box_y1]))
          self.__drag(np.array([self.box_x2, self.box_y2]))

          # move the vertices
          for v in nodes_to_move:
            self.vpos[v] = self.__drag(self.vpos[v])
        elif self.mouse_mode == self.MOUSE_MODE_SELECTION or self.mouse_mode == self.MOUSE_MODE_LOCK:
          # Not dragging an object and in selection or lock mode
          # - do selection rectangle

          tl = self.__drag_start_pos
          tr = (mouse_pos[0], tl[1])
          bl = (tl[0], mouse_pos[1])
          br = mouse_pos

          # for matplotlib: bottom left point, width, height
          self.selection_rect = [
              bl,
              abs(br[0] - bl[0]),
              abs(tl[1] - bl[1])
            ]

          for v in self.G.nodes():
            # if the vertex is within all four line segments making
            # up the rectangle, select it
            pos = self.vpos[v]
            if not ((self.PointLineDist(pos, tl, tr) == None) or
                    (self.PointLineDist(pos, tl, bl) == None) or
                    (self.PointLineDist(pos, tr, br) == None) or
                    (self.PointLineDist(pos, bl, br) == None)):
              if v not in self.selected_nodes:
                self.SelectVertex(v)
            else:
              if v in self.selected_nodes:
                self.DeselectVertex(v)

    plt.gca().cla()
    plt.gca().set_xlim(xmin=self.xmin, xmax=self.xmax)
    plt.gca().set_ylim(ymin=self.ymin, ymax=self.ymax)

    if self.selection_rect is not None:
      r = plt.Rectangle(self.selection_rect[0],
                        self.selection_rect[1],
                        self.selection_rect[2],
                        edgecolor='black',
                        facecolor='none',
                        #alpha=0.5,
                        lw=2)
      plt.gca().add_artist(r)

    deselected_nodes = set(self.G.nodes()) - set(self.selected_nodes)
    if deselected_nodes:
      nx.draw_networkx_nodes(
        self.G,
        pos=self.vpos,
        nodelist=list(deselected_nodes),
        node_color='#1f78b4',
      )

    if self.selected_nodes:
      nx.draw_networkx_nodes(
        self.G,
        pos=self.vpos,
        nodelist=self.selected_nodes,
        node_color='#e01039',
      )

    nx.draw_networkx_edges(
        self.G,
        pos=self.vpos
      )

    nx.draw_networkx_labels(
        self.G,
        pos=self.vpos
      )

    #nx.draw_networkx_edge_labels(
    #    self.G,
    #    pos=self.vpos
    #  )

    plt.tight_layout(pad=-1)
    self.canvas.draw()
    self.canvas.flush_events()

  def MPLButtonRelease(self, event):
    print(f'ButtonRelease')

  def MPLKeyPress(self, event):
    pass
    #print(f'KeyPress')

  def __bound_box(self, pos):
    if pos[0] < self.box_x1:
      self.box_x1 = pos[0]
    if pos[0] > self.box_x2:
      self.box_x2 = pos[0]
    if pos[1] < self.box_y1:
      self.box_y1 = pos[1]
    if pos[1] > self.box_y2:
      self.box_y2 = pos[1]

  def __drag(self, pos):
    new_pos = pos + self.__drag_vector
    # scale the drag vector on a collision with the canvas edge
    if new_pos[0] < self.xmin:
      self.__drag_vector = np.array([self.xmin - pos[0], self.__drag_vector[1]])
      new_pos = pos + self.__drag_vector
    if new_pos[0] > self.xmax:
      self.__drag_vector = np.array([self.xmax - pos[0], self.__drag_vector[1]])
      new_pos = pos + self.__drag_vector
    if new_pos[1] < self.ymin:
      self.__drag_vector = np.array([self.__drag_vector[0], self.ymin - pos[1]])
      new_pos = pos + self.__drag_vector
    if new_pos[1] > self.ymax:
      self.__drag_vector = np.array([self.__drag_vector[0], self.ymax - pos[1]])
      new_pos = pos + self.__drag_vector
    return new_pos

  def __execute_callback(self, call_list):
    for func in call_list:
      func()

  def OnResize(self, event):
    event.Skip()
    self.Refresh()

  def GetSelectedNodes(self):
    return self.selected_nodes

  def GetSelectedEdges(self):
    return self.selected_edges

  def SelectAll(self):
    self.DeselectAll()
    for v in self.G.nodes():
      self.selected_nodes.append(v)
    for e in self.G.edges():
      self.selected_edges.append(e)
    self.Refresh()

  def DeselectAll(self):
    self.selected_edges = []
    self.selected_nodes = []

  def SelectVertex(self, v):
    self.selected_nodes.append(v)
    self.__execute_callback(self.on_node_select_funcs)

  def DeselectVertex(self, v):
    self.selected_nodes.remove(v)

  def SelectEdge(self, e):
    self.selected_edges.append(e)

  def DeselectEdge(self, e):
    self.selected_edges.remove(e)

  def CreateEdgesFromSelection(self):
    if self.mouse_mode != self.MOUSE_MODE_LOCK:
      # hop around all of the selected vertices creating an edge
      # between every one of them
      for i in range(len(self.selected_nodes)):
        for j in range(i+1, len(self.selected_nodes)):
          u = self.selected_nodes[i]
          v = self.selected_nodes[j]
          if not self.G.has_edge(u, v):
            # labeling scheme if we start doing that
            #size = self.G.size()
            #l = "e%i" % size

            #while l in self.G.elabels_or_whatever:
            #  size = size + 1
            #  el = "e%i" % size

            e = u, v
            self.G.add_edge(*e)
            self.SelectEdge(e)

  def CreatePathFromSelection(self):
    if self.mouse_mode != self.MOUSE_MODE_LOCK:
      for i in range(len(self.selected_nodes) - 1):
        u = self.selected_nodes[i]
        v = self.selected_nodes[i+1]
        if not self.G.has_edge(u, v):
          e = u, v
          self.G.add_edge(*e)
          self.SelectEdge(e)
    self.__execute_callback(self.on_edge_create_funcs)

  def DeleteSelected(self):
    for v in self.selected_nodes:
      del self.vpos[v]
      del self.vlabel[v]
      del self.vcolor[v]

    self.G.remove_edges_from(self.selected_edges)
    self.G.remove_nodes_from(self.selected_nodes)
    self.selected_edges = []
    self.selected_nodes = []
    self.__execute_callback(self.on_node_delete_funcs)
    self.__execute_callback(self.on_edge_delete_funcs)

  def SearchNodes(self, p):
    vertices = self.G.nodes()
    for v in vertices:
      if self.TwoPointDist(p, self.vpos[v]) <= self.node_radius + self.node_search_dist:
        return v
    return None

  def SearchEdges(self, p):
    edges = self.G.edges()
    for e in edges:
      u_pos = self.vpos[e[0]]
      v_pos = self.vpos[e[1]]
      dist = self.PointLineDist(p, u_pos, v_pos)
      if dist is not None and dist >= 0.0 and dist <= self.edge_search_dist:
        return e
    return None

  def TwoPointDist(self, p1, p2):
    return math.sqrt( (p2[0] - p1[0])*(p2[0] - p1[0]) + 
              (p2[1] - p1[1])*(p2[1] - p1[1]) )

  def PointLineDist(self, p, endpoint1, endpoint2):
    x1, y1 = endpoint1[0], endpoint1[1]
    x2, y2 = endpoint2[0], endpoint2[1]
    x3, y3 = p[0], p[1]

    edgeLength = self.TwoPointDist(endpoint1, endpoint2)

    # avoid devide by zero in next computation
    if edgeLength == 0.0:
      return None

    U = ( ( (x3 - x1) * (x2 - x1) ) + ( (y3 - y1) * (y2 - y1) ) ) / (edgeLength * edgeLength)

    # the point isn't within the line segment
    if U < 0.0 or U > 1.0:
      return None

    intersection = np.array([x1 + U * (x2 - x1), y1 + U * (y2 - y1)])
    return self.TwoPointDist(intersection, p)

# end of class GraphCanvas
